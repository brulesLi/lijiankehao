<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>oc的细节  copy  block by brulesLi</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">oc的细节  copy  block</h1>
      <h2 class="project-tagline">我的第一个仓库</h2>
      <a href="https://github.com/brulesLi/lijiankehao" class="btn">View on GitHub</a>
      <a href="https://github.com/brulesLi/lijiankehao/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/brulesLi/lijiankehao/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="copy--mutablecopy" class="anchor" href="#copy--mutablecopy" aria-hidden="true"><span class="octicon octicon-link"></span></a>copy  mutableCopy</h1>

<p>什么是copy
Copy的字面意思是“复制”、“拷贝”，是一个产生副本的过程
常见的复制有：文件复制
作用：利用一个源文件产生一个副本文件
特点：
修改源文件的内容，不会影响副本文件
修改副本文件的内容，不会影响源文件
OC中的copy
作用：利用一个源对象产生一个副本对象
特点：
修改源对象的属性和行为，不会影响副本对象
修改副本对象的属性和行为，不会影响源对象</p>

<p>如何使用copy功能
一个对象可以调用copy或mutableCopy方法来创建一个副本对象
copy : 创建的是不可变副本(如NSString、NSArray、NSDictionary)
mutableCopy :创建的是可变副本(如NSMutableString、NSMutableArray、NSMutableDictionary)</p>

<p>使用copy功能的前提
copy : 需要遵守NSCopying协议，实现copyWithZone:方法
<a href="https://github.com/protocol" class="user-mention">@protocol</a> NSCopying</p>

<ul>
<li>(id)copyWithZone:(NSZone *)zone;</li>
</ul>

<p><a href="https://github.com/end" class="user-mention">@end</a></p>

<p>mutableCopy : 需要遵守NSMutableCopying协议，实现mutableCopyWithZone:方法
<a href="https://github.com/protocol" class="user-mention">@protocol</a> NSMutableCopying</p>

<ul>
<li>(id)mutableCopyWithZone:(NSZone *)zone;</li>
</ul>

<p><a href="https://github.com/end" class="user-mention">@end</a> </p>

<p>深复制（深拷贝，内容拷贝，deep copy）
源对象和副本对象是不同的两个对象
源对象引用计数器不变, 副本对象计数器为1（因为是新产生的）
本质是：产生了新的对象
浅复制（浅拷贝，指针拷贝，shallow copy）
源对象和副本对象是同一个对象
源对象（副本对象）引用计数器 + 1, 相当于做一次retain操作
本质是：没有产生新的对象</p>

<p>深复制（深拷贝，内容拷贝，deep copy）
源对象和副本对象是不同的两个对象
源对象引用计数器不变, 副本对象计数器为1（因为是新产生的）
本质是：产生了新的对象
浅复制（浅拷贝，指针拷贝，shallow copy）
源对象和副本对象是同一个对象
源对象（副本对象）引用计数器 + 1, 相当于做一次retain操作
本质是：没有产生新的对象</p>

<h2>
<a id="block" class="anchor" href="#block" aria-hidden="true"><span class="octicon octicon-link"></span></a>Block</h2>

<p>Block的定义格式
返回值类型 (^block变量名)(形参列表) = ^(形参列表) {</p>

<p>};</p>

<p>调用Block保存的代码
block变量名(实参);</p>

<p>使用typedef定义Block类型
typedef 返回值类型 (^block类型名称)(形参列表);</p>

<p>默认情况下, Block内部不能修改外面的局部变量
Block内部可以修改使用__block修饰的局部变量</p>

<p>.h
typedef void(^OperationBlock)();</p>

<p><a href="https://github.com/property" class="user-mention">@property</a>(nonatomic,copy)OperationBlock    operationBlock;//最好用copy  </p>

<p>.m 
    /**
     *block  最最关键是 一定先定义后  才能够调用（一定注意权限全局变量Block才能全局调用）
     *
     */</p>

<pre><code>/**
 *头部定义
 */
typedef void(^Test)();


typedef void (^TestPar)(NSString*);



typedef NSString* (^TeturnAndPar)(NSString*,NSString*);


/**
 *定义
 */
</code></pre>

<p>//习惯很重要虽然没有参数  在定义赋值右端还是写上()    因为结构上可以让你更有清楚思维</p>

<p>Test    test=^(){
    };
    TestPar   testparameter=^(NSString* par){
    };</p>

<pre><code>/**
 *有返回值在定义赋值 也要写返回值
 *
 */


TeturnAndPar   testAndPar=^(NSString *parter,NSString *parter2){
    return parter;
};


/**
 *调用
 *
 */
test();
testparameter(@"努力奋斗");
testAndPar(@"奋斗",@"努力");


/**
 *block的定义
 */
//无返回值 无参数
void(^testBlock)()=^{
    LJKLOG(@"cao  block");
};

//无返回值 有参数
void(^testParameterBlock)(NSString*,NSString*)=^(NSString *parameter1,NSString *parameter){
    [parameter  stringByAppendingString:parameter1];
};


//有返回值 有参数

NSString*(^testReturnAnpar)(NSString*,NSString*)=^(NSString *par1,NSString *par2){
    return    [par1  stringByAppendingString:par2];
};



/**
 *block的调用
 */
//无返回值 无参数
 testBlock();


//无返回值 有参数
testParameterBlock(@"cao",@"nimei");



//有返回值 有参数
NSString  *stringpp=testReturnAnpar(@"nima",@"SB");
LJKLOG(@"%@",stringpp);
</code></pre>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/brulesLi/lijiankehao">oc的细节  copy  block</a> is maintained by <a href="https://github.com/brulesLi">brulesLi</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

            <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("oc的细节  copy  block");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
